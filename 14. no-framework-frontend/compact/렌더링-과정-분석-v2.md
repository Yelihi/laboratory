# 프레임워크 없는 선언형 Todo 애플리케이션 - 렌더링 과정 분석 v2

## 목차

- [[#v2 주요 변경사항|v2 주요 변경사항]]
- [[#아키텍처 개요|아키텍처 개요]]
- [[#렌더링 과정 상세 분석|렌더링 과정 상세 분석]]
- [[#이벤트 핸들러 시스템|이벤트 핸들러 시스템]]
- [[#HTML Template 활용|HTML Template 활용]]
- [[#핵심 컴포넌트 분석|핵심 컴포넌트 분석]]
- [[#장점|장점]]
- [[#단점|단점]]
- [[#v1과의 비교|v1과의 비교]]

---

## v2 주요 변경사항

### 1. 이벤트 핸들러 시스템 도입

- ✅ **events 객체 추가**: 상태 변경 및 렌더링 트리거
- ✅ **이벤트 위임 패턴**: 효율적인 이벤트 처리
- ✅ **상태 변경 시 자동 렌더링**: `setInterval` 제거

### 2. HTML Template 활용

- ✅ **`<template>` 태그 사용**: 컴포넌트 구조를 HTML에 선언
- ✅ **Template 복제**: `template.content.firstElementChild.cloneNode(true)`
- ✅ **안전한 DOM 생성**: XSS 위험 감소

### 3. 컴포넌트 구조 개선

- ✅ **app.js 추가**: 루트 컴포넌트로 애플리케이션 구조 관리
- ✅ **이벤트 바인딩**: 컴포넌트 렌더링 시 이벤트 자동 연결
- ✅ **이벤트 위임**: 리스트 아이템에 효율적인 이벤트 처리

### 4. 렌더링 파이프라인 개선

- ✅ **events 파라미터 전달**: 모든 컴포넌트에 이벤트 핸들러 접근 가능
- ✅ **외부 트리거 제거**: `setInterval` 대신 이벤트 기반 렌더링
- ✅ **상태 기반 자동 렌더링**: 이벤트 발생 시 자동으로 `render()` 호출

---

## 아키텍처 개요

### 핵심 개념

```
State (상태)
  ↓
Events (이벤트 핸들러)
  ↓
View Functions (순수 함수)
  ↓
Virtual DOM (가상 DOM)
  ↓
Diff Algorithm (차이 비교)
  ↓
Real DOM Update (실제 DOM 업데이트)
```

### 파일 구조

```
compact/
├── index.html          # HTML 템플릿 (template 태그 포함)
├── index.js           # 애플리케이션 진입점, 상태 및 이벤트 관리
├── registry.js        # 컴포넌트 등록 시스템 (events 파라미터 추가)
├── applyDiff.js       # Diff 알고리즘 (변경 없음)
├── getTodos.js        # Mock 데이터 생성
└── view/
    ├── app.js         # 루트 컴포넌트 (신규)
    ├── todos.js       # Todo 리스트 컴포넌트 (개선)
    ├── filters.js     # 필터 컴포넌트
    └── counter.js     # 카운터 컴포넌트
```

---

## 렌더링 과정 상세 분석

### 1. 전체 렌더링 흐름

```
[사용자 인터랙션 또는 초기 로드]
  ↓
이벤트 발생 (예: addItem, deleteItem)
  ↓
events 핸들러 실행
  ↓
state 변경
  ↓
render() 호출 (자동)
  ↓
requestAnimationFrame으로 다음 프레임에 실행 예약
  ↓
registry.renderRoot() - 가상 DOM 생성
  ├─ 루트 요소 복제
  ├─ 각 컴포넌트 렌더링 (순수 함수 + events)
  └─ 자식 컴포넌트 자동 렌더링
  ↓
applyDiff() - Diff 알고리즘 실행
  ├─ 실제 DOM과 가상 DOM 비교
  ├─ 변경된 부분만 식별
  └─ 최소한의 DOM 조작으로 업데이트
  ↓
[화면 업데이트 완료]
```

### 2. 단계별 상세 분석

#### 단계 1: State 및 Events 초기화

```javascript:index.js
// 현재 todo 리스트의 state
const state = {
  todos: [],
  currentFilter: "All",
};

// event handler 생성
const events = {
  deleteItem: (index) => {
    state.todos.splice(index, 1);
    render();
  },
  addItem: (text) => {
    state.todos.push({ text, completed: false });
    render();
  },
};
```

**동작:**

1. `state` 객체에 애플리케이션 상태 저장
2. `events` 객체에 상태 변경 및 렌더링 트리거 함수 정의
3. **자동 렌더링**: 이벤트 핸들러 내부에서 `render()` 호출

**v1과의 차이:**

- ❌ v1: `setInterval`로 외부에서 트리거
- ✅ v2: 이벤트 기반으로 자동 렌더링

#### 단계 2: render() 함수

```javascript:index.js
const render = () => {
  window.requestAnimationFrame(() => {
    const main = document.querySelector(".todoapp");
    const newMain = registry.renderRoot(main, state, events);
    applyDiff(document.body, main, newMain);
  });
};
```

**동작:**

1. `requestAnimationFrame`으로 브라우저 렌더링 사이클과 동기화
2. `registry.renderRoot`에 `state`와 `events` 전달
3. 가상 DOM 생성 후 `applyDiff`로 실제 DOM 업데이트

**개선사항:**

- ✅ `events` 파라미터 추가로 컴포넌트에서 이벤트 핸들러 접근 가능

#### 단계 3: 가상 DOM 생성 (registry.renderRoot)

```javascript:registry.js
const renderRoot = (root, state, events) => {
  const cloneComponent = (root) => {
    return root.cloneNode(true);
  };

  return renderWrapper(cloneComponent)(root, state, events);
};
```

**동작:**

1. 실제 DOM 요소를 `cloneNode(true)`로 복제
2. `renderWrapper`로 컴포넌트 렌더링 래핑
3. `state`와 `events`를 모든 컴포넌트에 전달

**v1과의 차이:**

- ✅ `events` 파라미터 추가

#### 단계 4: 컴포넌트 렌더링 (renderWrapper)

```javascript:registry.js
const renderWrapper = (component) => {
  return (targetElement, state, events) => {
    const element = component(targetElement, state, events);

    // 자식 컴포넌트를 찾아서 등록
    const childComponents = element.querySelectorAll("[data-component]");

    Array.from(childComponents).forEach((target) => {
      const name = target.dataset.component;
      const child = registry[name];
      if (!child) return;

      target.replaceWith(child(target, state, events));
    });

    return element;
  };
};
```

**동작:**

1. 컴포넌트 함수 실행하여 새 요소 생성 (`state`, `events` 전달)
2. `data-component` 속성을 가진 자식 요소 탐색
3. 등록된 자식 컴포넌트를 찾아 재귀적으로 렌더링
4. **선언형 렌더링**: HTML에 `data-component`만 선언하면 자동으로 컴포넌트 연결

**v1과의 차이:**

- ✅ 모든 컴포넌트에 `events` 파라미터 전달

---

## 이벤트 핸들러 시스템

### 1. Events 객체 구조

```javascript:index.js
const events = {
  deleteItem: (index) => {
    state.todos.splice(index, 1);
    render();
  },
  addItem: (text) => {
    state.todos.push({ text, completed: false });
    render();
  },
};
```

**특징:**

- **상태 변경**: 이벤트 핸들러 내부에서 `state` 직접 수정
- **자동 렌더링**: 상태 변경 후 `render()` 자동 호출
- **단방향 데이터 흐름**: 이벤트 → 상태 변경 → 렌더링

### 2. 이벤트 바인딩 (app.js)

```javascript:view/app.js
const addEvent = (targetElement, events) => {
  targetElement
    .querySelector(".new-todo")
    .addEventListeners("keypress", (event) => {
      if (event.key === "Enter") {
        events.addItem(event.target.value);
        event.target.value = "";
      }
    });
};
```

**동작:**

1. 컴포넌트 렌더링 시 이벤트 리스너 등록
2. 사용자 입력 시 `events.addItem()` 호출
3. 상태 변경 및 자동 렌더링

### 3. 이벤트 위임 (todos.js)

```javascript:view/todos.js
// todoList 내 이벤트 위임
newTodoList.addEventListener("click", (e) => {
  if (e.target.matches("button.destroy")) {
    events.deleteItem(e.target.dataset.index);
  }
});
```

**장점:**

- ✅ **성능 최적화**: 각 아이템에 개별 리스너 대신 부모에 하나만 등록
- ✅ **동적 요소 처리**: 나중에 추가된 요소도 자동으로 이벤트 처리
- ✅ **메모리 효율**: 리스너 개수 최소화

**동작:**

1. `dataset.index`로 삭제할 아이템 식별
2. `events.deleteItem()` 호출
3. 상태 변경 및 자동 렌더링

---

## HTML Template 활용

### 1. Template 태그 정의

```html:index.html
<template id="todo-item">
  <li>
    <div class="view">
      <input class="toggle" type="checkbox" />
      <label></label>
      <button class="destroy"></button>
    </div>
    <input class="edit" />
  </li>
</template>

<template id="todo-app">
  <section class="todoapp">
    <!-- ... 전체 앱 구조 ... -->
  </section>
</template>
```

**특징:**

- ✅ **선언적 구조**: HTML에 컴포넌트 구조 정의
- ✅ **재사용 가능**: 여러 번 복제하여 사용
- ✅ **안전한 생성**: XSS 위험 감소 (innerHTML 대신)

### 2. Template 사용 (todos.js)

```javascript:view/todos.js
let template;

const createNewTodoNode = () => {
  if (!template) {
    template = document.getElementById("todo-item");
  }

  return template.content.firstElementChild.cloneNode(true);
};
```

**동작:**

1. `template.content.firstElementChild`로 템플릿 내용 접근
2. `cloneNode(true)`로 깊은 복사
3. 복제된 요소에 데이터 바인딩

**v1과의 차이:**

- ❌ v1: `innerHTML`로 HTML 문자열 삽입 (XSS 위험)
- ✅ v2: Template 복제로 안전한 DOM 생성

### 3. Template 사용 (app.js)

```javascript:view/app.js
let template;

const getTemplate = () => {
  if (!template) {
    template = document.getElementById("todo-app");
  }

  return template.content.firstElementChild.cloneNode(true);
};

export default (targetElement) => {
  const newApp = targetElement.cloneNode(true);
  newApp.innerHTML = "";
  newApp.appendChild(getTemplate());
  addEvent(newApp, events);
  return newApp;
};
```

**동작:**

1. 타겟 요소 복제
2. 내용 비우기
3. Template에서 앱 구조 복제하여 추가
4. 이벤트 바인딩

---

## 핵심 컴포넌트 분석

### 1. app.js - 루트 컴포넌트

```javascript:view/app.js
export default (targetElement) => {
  const newApp = targetElement.cloneNode(true);
  newApp.innerHTML = "";
  newApp.appendChild(getTemplate());

  addEvent(newApp, events);
  return newApp;
};
```

**역할:**

- 루트 컴포넌트로 전체 앱 구조 관리
- Template에서 앱 구조 복제
- 이벤트 바인딩 (새 Todo 추가)

**특징:**

- `events` 파라미터를 받지만 함수 시그니처에는 없음 (클로저 활용 가능)

### 2. todos.js - Todo 리스트 (개선)

```javascript:view/todos.js
export default (targetElement, { todos }, events) => {
  const newTodoList = targetElement.cloneNode(true);
  newTodoList.innerHTML = "";

  todos
    .map((todo, index) => getTodoElement(todo, index, events))
    .forEach((element) => {
      newTodoList.appendChild(element);
    });

  newTodoList.addEventListener("click", (e) => {
    if (e.target.matches("button.destroy")) {
      events.deleteItem(e.target.dataset.index);
    }
  });

  return newTodoList;
};
```

**개선사항:**

- ✅ **Template 사용**: `createNewTodoNode()`로 안전한 DOM 생성
- ✅ **이벤트 위임**: 부모 요소에 이벤트 리스너 등록
- ✅ **appendChild 사용**: `innerHTML` 대신 안전한 DOM 조작
- ✅ **dataset.index**: 삭제할 아이템 식별

**v1과의 차이:**

```javascript
// v1: innerHTML 사용
newTodoList.innerHTML = todoElements;

// v2: Template + appendChild
todos.map(getTodoElement).forEach(element => {
  newTodoList.appendChild(element);
});
```

### 3. getTodoElement 함수

```javascript:view/todos.js
const getTodoElement = (todo, index, events) => {
  const { text, completed } = todo;
  const newTodoElement = createNewTodoNode();

  newTodoElement.querySelector("input.edit").value = text;
  newTodoElement.querySelector("label").textContent = text;

  if (completed) {
    newTodoElement.classList.add("completed");
    newTodoElement.querySelector("input.toggle").checked = true;
  }

  newTodoElement.querySelector("button.destroy").dataset.index = index;
  return newTodoElement;
};
```

**동작:**

1. Template에서 새 Todo 요소 생성
2. 데이터 바인딩 (text, completed 상태)
3. `dataset.index`로 삭제 시 식별 가능하도록 설정

### 4. filters.js - 필터 버튼

```javascript:view/filters.js
export default (targetElement, { currentFilter }) => {
  const newCounter = targetElement.cloneNode(true);

  Array.from(newCounter.querySelectorAll("li a")).forEach((a) => {
    if (a.textContent === currentFilter) {
      a.classList.add("selected");
    } else {
      a.classList.remove("selected");
    }
  });

  return newCounter;
};
```

**특징:**

- v1과 동일 (변경 없음)
- 현재 선택된 필터에 `selected` 클래스 추가

### 5. counter.js - Todo 개수

```javascript:view/counter.js
export default (targetElement, { todos }) => {
  const newCounter = targetElement.cloneNode(true);
  newCounter.textContent = getTodoCount(todos);
  return newCounter;
};
```

**특징:**

- v1과 동일 (변경 없음)
- 완료되지 않은 Todo 개수 계산 및 표시

---

## 장점

### 1. 이벤트 기반 렌더링

- ✅ **자동 렌더링**: 이벤트 발생 시 자동으로 `render()` 호출
- ✅ **외부 트리거 제거**: `setInterval` 불필요
- ✅ **반응형 UI**: 사용자 인터랙션에 즉시 반응

### 2. HTML Template 활용

- ✅ **안전한 DOM 생성**: XSS 위험 감소
- ✅ **선언적 구조**: HTML에 컴포넌트 구조 정의
- ✅ **재사용 가능**: Template을 여러 번 복제하여 사용

### 3. 이벤트 위임 패턴

- ✅ **성능 최적화**: 각 아이템에 개별 리스너 대신 부모에 하나만
- ✅ **동적 요소 처리**: 나중에 추가된 요소도 자동으로 이벤트 처리
- ✅ **메모리 효율**: 리스너 개수 최소화

### 4. 컴포넌트 구조 개선

- ✅ **app.js 추가**: 루트 컴포넌트로 구조 관리
- ✅ **이벤트 전달**: 모든 컴포넌트에 `events` 접근 가능
- ✅ **관심사 분리**: 이벤트 로직과 렌더링 로직 분리

### 5. 프레임워크 독립성

- ✅ **의존성 없음**: 외부 라이브러리 불필요
- ✅ **번들 크기 작음**: 최소한의 코드로 구현
- ✅ **학습 곡선 낮음**: 순수 JavaScript만 사용

---

## 단점

### 1. 기능 제한

- ❌ **이벤트 핸들러 제한적**: 현재 `addItem`, `deleteItem`만 구현
- ❌ **상태 관리 단순**: 복잡한 상태 관리 패턴 부재
- ❌ **라이프사이클 없음**: 컴포넌트 마운트/언마운트 처리 없음

### 2. 성능 이슈

- ❌ **전체 트리 비교**: 큰 DOM 트리에서 성능 저하 가능
- ❌ **불필요한 복제**: `cloneNode(true)`로 전체 요소 복제
- ❌ **이벤트 리스너 중복**: 렌더링마다 이벤트 리스너 재등록 가능

### 3. 개발 경험

- ❌ **타입 안정성 없음**: TypeScript 미지원
- ❌ **에러 처리 부족**: 잘못된 컴포넌트 등록 시 명확한 에러 없음
- ❌ **디버깅 어려움**: 프레임워크 도구 없어 디버깅 복잡

### 4. 유지보수

- ❌ **이벤트 리스너 관리**: 렌더링마다 리스너 재등록 (메모리 누수 가능)
- ❌ **컴포넌트 간 통신 복잡**: 직접적인 통신 메커니즘 없음
- ❌ **코드 중복 가능**: 비슷한 로직 반복 가능

### 5. 확장성

- ❌ **라우팅 없음**: SPA 라우팅 기능 부재
- ❌ **상태 관리 라이브러리 없음**: Redux, MobX 같은 도구 없음
- ❌ **빌드 도구 없음**: 번들링, 최적화 도구 없음

---

## v1과의 비교

### 주요 개선사항

| 항목 | v1 | v2 |
|------|----|----|
| **렌더링 트리거** | `setInterval` (외부) | 이벤트 기반 (자동) |
| **이벤트 핸들러** | 없음 | `events` 객체 |
| **DOM 생성** | `innerHTML` (문자열) | Template 복제 |
| **이벤트 처리** | 없음 | 이벤트 위임 패턴 |
| **루트 컴포넌트** | 없음 | `app.js` |
| **XSS 위험** | 있음 (`innerHTML`) | 낮음 (Template) |

### 코드 비교

#### 렌더링 트리거

```javascript
// v1
window.setInterval(() => {
  state.todos = getTodos();
  render();
}, 1000);

// v2
const events = {
  addItem: (text) => {
    state.todos.push({ text, completed: false });
    render(); // 자동 렌더링
  },
};
```

#### DOM 생성

```javascript
// v1: innerHTML 사용
const todoElements = todos.map(getTodoElement).join("");
newTodoList.innerHTML = todoElements;

// v2: Template + appendChild
todos.map((todo, index) => getTodoElement(todo, index, events))
  .forEach((element) => {
    newTodoList.appendChild(element);
  });
```

#### 이벤트 처리

```javascript
// v1: 없음

// v2: 이벤트 위임
newTodoList.addEventListener("click", (e) => {
  if (e.target.matches("button.destroy")) {
    events.deleteItem(e.target.dataset.index);
  }
});
```

---

## 요약

### v2 핵심 패턴

1. **이벤트 기반 렌더링**: 이벤트 발생 → 상태 변경 → 자동 렌더링
2. **HTML Template**: 안전한 DOM 생성
3. **이벤트 위임**: 효율적인 이벤트 처리
4. **컴포넌트 구조**: 루트 컴포넌트로 구조 관리
5. **선언형 렌더링**: View = f(State, Events)

### 적합한 사용 사례

- ✅ 작은 규모의 인터랙티브 애플리케이션
- ✅ 프레임워크 없이 순수 JavaScript로 구현하고 싶을 때
- ✅ 학습 목적 (React 같은 프레임워크의 원리 이해)
- ✅ 번들 크기가 중요한 환경

### 부적합한 사용 사례

- ❌ 복잡한 상태 관리가 필요한 애플리케이션
- ❌ 대규모 팀 프로젝트
- ❌ 빠른 개발 속도가 필요한 프로젝트
- ❌ 풍부한 생태계가 필요한 프로젝트

---

## 관련 파일

- [index.js](index.js) - 애플리케이션 진입점, 상태 및 이벤트 관리
- [registry.js](registry.js) - 컴포넌트 등록 시스템
- [applyDiff.js](applyDiff.js) - Diff 알고리즘
- [view/app.js](view/app.js) - 루트 컴포넌트
- [view/todos.js](view/todos.js) - Todo 리스트 컴포넌트
- [view/filters.js](view/filters.js) - 필터 컴포넌트
- [view/counter.js](view/counter.js) - 카운터 컴포넌트
